#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jan  2 10:38:07 2020

Calculates mean properties for a control protocol on a 3x3 Ising spin system
from trajectories generated by protocol_run.py

@author: MirandaLouwerse
"""

import numpy as np
from ProtocolParameters import *

# run Monte Carlo for protocol work estimation

def calc_hamiltonian(sigma,h,J,num_spins):
    
    ham = -J*(sigma[0]*sigma[1]+sigma[1]*sigma[2]+sigma[3]*sigma[4]+ # coupling interactions between internal spins
               sigma[4]*sigma[5]+sigma[6]*sigma[7]+sigma[7]*sigma[8]+
               sigma[0]*sigma[3]+sigma[3]*sigma[6]+sigma[1]*sigma[4]+
               sigma[4]*sigma[7]+sigma[2]*sigma[5]+sigma[5]*sigma[8])
    
    # coupling interactions between spins and boundary conditions
    # spins 3 and 5 have spin up conditions
    # spins 1 and 7 have spin down conditions
    ham += -J*(sigma[3]+sigma[5])-J*(-sigma[1]-sigma[7]) 
    
    ham += -h[0]*(sigma[0]+sigma[2]+sigma[6]+sigma[8])-h[1]*(sigma[1]+sigma[7])\
            -h[2]*(sigma[3]+sigma[5])-h[3]*sigma[4]
    
    return ham


def calc_conj_force(sigma,num_blocks):
    conj_force = np.zeros((num_blocks))
    
    conj_force[0] = sigma[0]+sigma[2]+sigma[6]+sigma[8]
    conj_force[1] = sigma[1]+sigma[7]
    conj_force[2] = sigma[3]+sigma[5]
    conj_force[3] = sigma[4]
    
    return conj_force


def get_state_from_index(index,spin_number):
    
    binary_string = '{0:b}'.format(index)
    if len(binary_string) < spin_number:
        binary_string = (spin_number-len(binary_string))*'0' + binary_string
    state = np.zeros((spin_number))

    for i in range(spin_number):
        if binary_string[i] == '0':
            state[i] = -1
        else:
            state[i] = 1
    
    return state


def h_at_time(time,protocol_time,string,string_times):
    
    scaled_time = float(time)/float(protocol_time)
    
    if scaled_time <= 0.0:
        h = string[0,:]
    
    for i in range(len(string_times)):
        if string_times[i] < scaled_time:
            h = np.zeros((num_blocks))
            for j in range(num_blocks):
                h[j] = (string[i+1,j]-string[i,j])*(scaled_time-string_times[i])\
                    /(string_times[i+1]-string_times[i])+string[i,j]
    if scaled_time >= 1.0:
        h = string[-1,:]
    
    return h


def calc_eqm_properties(string,string_times,J,beta,num_spins,num_blocks,protocol_time):
    # calculate eqm mean force, energy, entropy and FE
    
    traj_mean_force = np.zeros((protocol_time+1,num_blocks))
    traj_FE = np.zeros((protocol_time+1))
    traj_energy = np.zeros((protocol_time+1))
    traj_entropy = np.zeros((protocol_time+1))
    for k in range(protocol_time+1):
        h_here = h_at_time(k,protocol_time,string,string_times)
        for i in range(2**num_spins):
            state_here = get_state_from_index(i,num_spins)
            conj_force = calc_conj_force(state_here,num_blocks)
            ham_here = calc_hamiltonian(state_here,h_here,J,num_spins)
            
            traj_mean_force[k] += conj_force*np.exp(-beta*ham_here)
            traj_FE[k] += np.exp(-beta*ham_here)
            traj_energy[k] += ham_here*np.exp(-beta*ham_here)
        traj_mean_force[k] = traj_mean_force[k]/traj_FE[k]
        traj_energy[k] = traj_energy[k]/traj_FE[k]
        traj_FE[k] = -np.log(traj_FE[k])
        traj_entropy[k] = traj_energy[k]-traj_FE[k]
        traj_energy[k] = traj_energy[k]+np.sum(h_here*traj_mean_force[k])
    
    return traj_mean_force,traj_FE,traj_energy,traj_entropy


def calc_conj_force_eqm_trajectory(mean_eqm_trajectory,protocol_time):
    conj_force_traj = np.zeros((protocol_time,num_blocks))
    
    for k in range(protocol_time):
        conj_force = calc_conj_force(mean_eqm_trajectory[k,:],num_blocks)
        for j in range(num_blocks):
            conj_force_traj[k,j] = conj_force[j]
    
    return conj_force_traj


string = np.load("{}/control_protocol.npy".format(string_directory))
R = len(string)
string_times = np.linspace(0,1,R)

for protocol_time in protocol_time_list:
    
    h_trajectory = np.zeros((protocol_time+1,num_blocks))
    for k in range(protocol_time+1):
        h_here = h_at_time(k,protocol_time,string,string_times)
        h_trajectory[k,:] = h_here
    
    # calculate eqm properties: mean force, energy, entropy, free energy
    eqm_mean_force,eqm_FE,eqm_energy,eqm_entropy = calc_eqm_properties(string,string_times,J,beta,num_spins,num_blocks,protocol_time)
    
    # calculate neq properties: mean force, per coord ex power and work plus SEM measurement
    traj_neq_mean_force = np.zeros((num_traj,protocol_time,num_blocks))
    traj_power = np.zeros((num_traj,protocol_time,num_blocks))
    traj_work = np.zeros((num_traj,num_blocks))
    quasistatic_power = np.zeros((protocol_time,num_blocks))
    neq_prob_distr = np.zeros((protocol_time,2**num_spins))
    for i in range(num_traj):
        traj_i = np.load("{}/duration_{:.0f}/trajectories/traj_{:.0f}.npy"
                .format(string_directory,protocol_time,i))
        for k in range(protocol_time):
            state = traj_i[k,:]
            state_index = get_index_from_state(state,num_spins)
            neq_prob_distr[k,state_index] += 1.0/float(num_traj)

            conj_force = calc_conj_force(state,num_blocks)
            
            traj_neq_mean_force[i,k,:] = conj_force
            traj_power[i,k,:] = -(h_trajectory[k+1]-h_trajectory[k])*\
                    (conj_force)
            if i == 0:
                quasistatic_power[k,:] = -(h_trajectory[k+1]-h_trajectory[k])*\
                    (eqm_mean_force[k])
    traj_work = traj_power.sum(axis=1)
    quasistatic_work = quasistatic_power.sum(axis=0)
    
    mean_neq_conj_force = np.mean(traj_neq_mean_force,axis=0)
    sem_neq_conj_force = 1.0/np.sqrt(num_traj)*np.std(traj_neq_mean_force,axis=0)
    
    mean_power = np.mean(traj_power,axis=0)
    sem_power = 1.0/np.sqrt(num_traj)*np.std(traj_power,axis=0)
    
    mean_work = np.mean(traj_work,axis=0)
    sem_work = 1.0/np.sqrt(num_traj)*np.std(traj_work,axis=0)
    
    # calculate neq distribution properties
    neq_entropy = np.zeros((protocol_time))
    neq_energy = np.zeros((protocol_time))
    neq_coupling = np.zeros((protocol_time))
    for k in range(protocol_time):
        distr_here = neq_prob_distr[k,:]
        h_here = h_at_time(k,protocol_time,string,string_times)
        
        for i in range(2**num_spins):
            state = get_state_from_index(i,num_spins)
            conj_force = calc_conj_force(state,num_blocks)
            ham_here = calc_hamiltonian(state,h_here,J,num_spins)
            coupling_energy = 0.0
            for j in range(num_blocks):
                coupling_energy += -h_here[j]*conj_force[j]
            internal_energy = ham_here-coupling_energy
            prob_here = distr_here[i]
            
            neq_coupling[k] += prob_here*coupling_energy
            neq_energy[k] += prob_here*internal_energy
            if prob_here == 0:
                neq_entropy[k] += 0
            else:
                neq_entropy[k] += -prob_here*np.log(prob_here)
    neq_free_energy = neq_energy+neq_coupling-neq_entropy

    # save calculated data
    np.save("{}/duration_{:.0f}/eqm_mean_force.npy".format(string_directory,protocol_time),eqm_mean_force)
    np.save("{}/duration_{:.0f}/eqm_FE.npy".format(string_directory,protocol_time),eqm_FE)
    np.save("{}/duration_{:.0f}/eqm_energy.npy".format(string_directory,protocol_time),eqm_energy)
    np.save("{}/duration_{:.0f}/eqm_entropy.npy".format(string_directory,protocol_time),eqm_entropy)
    np.save("{}/duration_{:.0f}/neq_coupling_energy.npy".format(string_directory,protocol_time),neq_coupling)
    np.save("{}/duration_{:.0f}/neq_free_energy.npy".format(string_directory,protocol_time),neq_free_energy)
    np.save("{}/duration_{:.0f}/neq_internal_energy.npy".format(string_directory,protocol_time),neq_energy)
    np.save("{}/duration_{:.0f}/neq_entropy.npy".format(string_directory,protocol_time),neq_entropy)
    np.save("{}/duration_{:.0f}/quasistatic_power.npy".format(string_directory,protocol_time),quasistatic_power)
    np.save("{}/duration_{:.0f}/quasistatic_work.npy".format(string_directory,protocol_time),quasistatic_work)
    np.save("{}/duration_{:.0f}/traj_neq_mean_force.npy".format(string_directory,protocol_time),traj_neq_mean_force)
    np.save("{}/duration_{:.0f}/traj_excess_power.npy".format(string_directory,protocol_time),traj_excess_power)
    np.save("{}/duration_{:.0f}/traj_excess_work.npy".format(string_directory,protocol_time),traj_work)
    np.save("{}/duration_{:.0f}/mean_neq_conj_force.npy".format(string_directory,protocol_time),mean_neq_conj_force)
    np.save("{}/duration_{:.0f}/sem_neq_conj_force.npy".format(string_directory,protocol_time),sem_neq_conj_force)
    np.save("{}/duration_{:.0f}/mean_power.npy".format(string_directory,protocol_time),mean_power)
    np.save("{}/duration_{:.0f}/sem_power.npy".format(string_directory,protocol_time),sem_power)
    np.save("{}/duration_{:.0f}/mean_work.npy".format(string_directory,protocol_time),mean_work)
    np.save("{}/duration_{:.0f}/sem_work.npy".format(string_directory,protocol_time),sem_work)